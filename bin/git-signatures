#!/usr/bin/env bash

set -o pipefail

VERSION="v0.1.0"
PROGRAM="${0##*/}"
COMMAND="$1"

GETOPT=$(command -v gnu-getopt || command -v getopt)
DATE=$(command -v gdate || command -v date)
SHUF=$(command -v gshuf || command -v shuf)
GPG=$(command -v gpg2 || command -v gpg || echo gpg)

main(){
	path_check git openssl xargs $GPG sed || exit 1

	case $COMMAND in
		""|"-h"|"--help"|"help"|"usage") usage "" 0;;
		"-v"|"--version") cmd_version; exit 0;;
	esac

	! type "cmd_$COMMAND" > /dev/null && usage

	shift;
	"cmd_$COMMAND" "$@"
}

usage() {
	topic="${1:-}"
	code="${2:-1}"
	case $topic in

		"" ) cat <<-EOF
		git signatures <command> [<args>]

		Git Signatures is a system for adding and verifying one or more PGP
		signatures to a given git reference.

		Git Signatures works by appending one of more signatures of a given
		ref hash to the git notes interface for that ref at 'refs/signatures'.

		In addition to built in commit signing that allows -authors- to sign,
		Git Signatures allows parties other than the author to issue "approval"
		signatures to a ref, allowing for decentralized cryptographic proof of
		code review. This is also useful for automation use cases where CI
		systems to be able to add a signatures to a repo if a repo if all tests
		pass successfully.

		In practice Git Signatures allows for tamper evident design and brings
		strong code attestations to a deployment process.

		Commands
		--------

		* git signatures init
		    Setup git to automatically include signatures on push/pull

		* git signatures import
		    Import all PGP keys specified in .gitsigners file to local
		    GnuPG keychain allowing for verifications.

		* git signatures show
		    Show signatures for a given ref.

		* git signatures add
		    Add a signature to a given ref.

		* git signatures verify
		    Verify signatures for a given ref.

		* git signatures pull
		    Pull all signatures for all refs from origin.

		* git signatures push
		    Push all signatures for all refs to origin.

		* git signatures version
		    Report the version number.
		EOF
		;;

		"init" ) cat <<-EOF
		git signatures init

		Configure local git repo to automatically include signatures on fetch
		and push.
		EOF
		;;

		"import" ) cat <<-EOF
		git signatures import

		Import all PGP keys specified in .gitsigners file to local GnuPG
		keychain allowing for verifications.
		EOF
		;;

		"show" ) cat <<-EOF
		git signatures show [options] [<ref>]

		Show signatures for a given ref

		Options:

		* --raw -r:
		  Show raw output from gnupg
		EOF
		;;

		"add" ) cat <<-EOF
		git signatures add [options] [<ref>]

		Add PGP signature to a ref.

		Options:

		* --key -k:
		  Specify ID of a local PGP key that should be used for signing

		* --push -p:
		  Automatically push to remote after adding signature locally
		EOF
		;;

		"verify" ) cat <<-EOF
		git signatures verify [options] [<ref>]

		Verify git signatures and only return 0 if conditions met.

		Useful for CI or scripting.

		Options:

		* --min-count=<num> -m <num>:
		  Only return 0 if the specified number of unique valid signatures
		  exists on the specified ref

		* --trust-db=<name> -t <name>:
		  Specify a specific GnuPG trustdb to validate signatures against.

		  Useful if you want to verify signatures from isolated sets of
		  possible keys.
		EOF
		;;

		"pull" ) cat <<-EOF
		git signatures pull [<ref>]

		Pull remote signatures for a given ref from origin
		EOF
		;;

		"push" ) cat <<-EOF
		git signatures push [<ref>]

		Push local signatures for a given ref to origin
		EOF
		;;

		"version" ) cat <<-EOF
		git signatures version

		Get current version. Do you really need help with this?
		EOF
		;;

	esac

	exit $code
}

error() {
	reason="${1:-}"
	code=1
	case $reason in
		"invalid_private_key" ) read -r -d '' template  <<-EOF
			Unable to create signature.

			This is not a valid private key according to GnuPG: "%s"

			Please set a public public key in your git configuration that has a
			valid local private key you control.

			> gpg --list-secret-keys
			> git config user.signingKey "YOURKEYID"
		EOF
		;;

		"verify_failed" ) read -r -d '' template  <<-EOF
			Failed to find enough verifed signatures to satisfy: min_count=%s

			Signature verification could fail simply because your local gnupg
			keychain and trustdb does not contain the required keys.

			For detailed signature status run:

			> git signatures show
		EOF
		;;

		"gpg_status_fd" ) read -r -d '' template  <<-EOF
			Unable to parse gpg's status-fd output.

			%s
		EOF
		code=99
		;;

		* ) read -r -d '' template <<-EOF
			Unknown error. Good luck!

			%s
		EOF
		code=100
		;;

	esac

	# shellcheck disable=SC2059
	printf "${template}\\n" "${@:2}" >&2

	exit $code
}

path_check() {
	for item in "$@"; do
		if ! command -v "$item" >/dev/null; then
			printf "%s not found in \$PATH \\n" "$item";
			return 1;
		fi
	done
	return 0
}

parse_sigstatus(){
	local rev="$1"
	local sigrev="$2"
	local sig_key sig_frp sig_primary_frp sig_time sig_date sig_author sig_status sig_valid
	while read -r values; do
		local status_code array pos
		IFS=" " read -r -a array <<< "$values"
		[[ "${array[0]}" == "[GNUPG:]" ]] || error "gpg_status_fd"
		status_code=${array[1]}

		#echo "$values" >&2
		# See `doc/DETAILS` in gnupg's repository for the message format
		# https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS
		case $status_code in
			NEWSIG)
				sig_author="${sig_author:-Unknown User <${array[2]}>}"
			;;
			GOODSIG|EXPSIG|EXPKEYSIG|REVKEYSIG|BADSIG)
				sig_key="${array[2]}"
				pos=$((11+${#status_code}+${#sig_key}))
				sig_author="${values:$pos}"
				sig_status="$status_code"
			;;
			ERRSIG)
				sig_key="${array[2]}"
				sig_time="${array[6]}"
				sig_fpr="${array[8]}"
				sig_status="$status_code"
			;;
			VALIDSIG)
				sig_fpr="${array[2]}"
				sig_time="${array[4]}"
				sig_primary_frp="${array[11]}"
				if [[ "$sig_status" == "GOODSIG" ]]; then
					sig_status="$status_code"
				fi
			;;
			TRUST_*)
				sig_trust="${status_code//TRUST_/}"
			;;
			# Things that can be ignored
			KEYEXPIRED);; # this message is also emitted for expired subkeys
				      # EXPKEYSIG will be emitted for the key in question
			KEYREVOKED);; # similarly
			NO_PUBKEY);;  # will produce ERRSIG
			KEY_CONSIDERED);;
			SIG_ID);;
			PLAINTEXT*);;
			VERIFICATION_COMPLIANCE_MODE);;
			# Fallback
			*)
				error "gpg_status_fd" "Unknown gpg status code $status_code"
			;;
		esac
	done

	sig_key="${sig_key:-UNKNOWN}"
	sig_trust="${sig_trust:-UNKNOWN}"
	if [[ -n "$sig_time" ]]; then
		sig_date="$($DATE -d @"$sig_time")"
	else
		sig_date=UNKNOWN
	fi

	case "$sig_status" in
	VALIDSIG)
		if [[ "$rev" != "$sigrev" ]]; then
			# this is a replay attack
			sig_status=INVALID
		else
			sig_status=VALID
		fi
		;;
	GOODSIG)  error "gpg_status_fd" "gpg emited GOODSIG status but didn't emit VALIDSIG status, this is unexpected";;
	EXPSIG);;
	EXPKEYSIG) sig_status=EXPKEY;;
	REVKEYSIG) sig_status=REVKEY;;
	BADSIG) sig_status=INVALID;;
	ERRSIG) sig_status=UNKNOWN;;
	*) error "gpg_status_fd" "bad state";;
	esac

	echo "$sig_key|$sig_status|$sig_trust|$sig_date|$sig_author"
}

get_sigs() {
	local ref="$1"
	local rev=$(git rev-parse "$ref")
	local plainfile=$(mktemp -qp /dev/shm gpg.XXXXXXXXXX || mktemp gpg.XXXXXXXXXX)
	local status plaintext
	{ git notes --ref signatures show "$ref" 2>/dev/null | grep -v "^$" || true; } | while IFS='' read -r line; do
		# shellcheck disable=SC2005
		status=$(echo -n "$line" \
		| openssl base64 -d -A \
		| $GPG -d --trustdb-name="$trust_db" --status-fd=3 3>&1 1>"$plainfile" 2>/dev/null)
		plaintext=$(cat "$plainfile")
		parse_sigstatus "$rev" "$plaintext" <<< "$status"
	done
	status=$? ; [[ $status != 0 ]] && exit $status # TODO: remove after switching to -e
	rm "$plainfile"
}

cmd_version() {
	echo "$PROGRAM $VERSION"
}

cmd_add() {
	local opts key_id push=0
	opts="$($GETOPT -o hpk: -l help,push,key: -n "$PROGRAM" -- "$@")";
	eval set -- "$opts"
	while true; do case $1 in
		-h|--help) usage add;;
		-k|--key) key_id="$2"; shift 2 ;;
		-p|--push) push=1; shift ;;
		--) shift; break ;;
	esac done
	[ "$#" -gt 2 ] && usage add
	ref=${1:-HEAD}
	key=${key_id:-$(git config user.signingKey)}
	$GPG --list-secret-keys "$key" &> /dev/null || error "invalid_private_key" "$key"
	signature=$( \
		git rev-parse "$ref" \
		| $GPG --compress-algo none --sign --local-user "$key" \
		| openssl base64 -A \
	)
	printf "%s" "$signature" | git notes --ref signatures append --file=-

	TAG_TARGET=$(git rev-parse refs/notes/signatures 2>/dev/null) && git tag -f latest-signature "$TAG_TARGET"

	[[ "$push" -eq "0" ]] || $PROGRAM push
}

cmd_show() {
	local opts raw=0 trust_db="trustdb.gpg"
	opts="$($GETOPT -o hrt: -l help,raw,trust-db: -n "$PROGRAM" -- "$@")";
	eval set -- "$opts"
	while true; do case $1 in
		-h|--help) usage show;;
		-r|--raw) raw=1; shift ;;
		-t|--trust-db) trust_db="$2"; shift 2;;
		--) shift; break ;;
	esac done
	[ "$#" -gt 1 ] && usage show
	ref=${1:-HEAD}
	if [ "$raw" -ne 1 ]; then
		printf " %-16s | %-10s | %-9s | %-28s | %-50s \\n" \
			"Public Key ID" "Status" "Trust" "Date" "Signer Name"
		printf "=%.0s" {1..119}
		printf "\\n"
	fi
	get_sigs "$ref" | while IFS='' read -r sig_parsed; do
		[ "$raw" -eq "1" ] && echo "$sig_parsed" && continue
		IFS="|" read -d '' -ra sig < <(echo -n "$sig_parsed")
		printf " %-16s | %-10s | %-9s | %28s | %-50s\\n" \
			"${sig[0]}" "${sig[1]}" "${sig[2]}" "${sig[3]}" "${sig[4]}"
	done
}

cmd_verify() {
	local opts min_count=1 trust_db="trustdb.gpg"
	opts="$($GETOPT -o hm:t: -l help,min-count:,trust-db: -n "$PROGRAM" -- "$@")";
	eval set -- "$opts"
	while true; do case $1 in
		-h|--help) usage verify;;
		-m|--min-count) min_count="$2"; shift 2 ;;
		-t|--trust-db) trust_db="$2"; shift 2;;
		--) shift; break ;;
	esac done
	[ "$#" -gt 1 ] && usage verify
	ref=${1:-HEAD}
	valid_count=$( \
		cmd_show --raw --trust-db="$trust_db" "$ref" \
		| sed -n 's/^\([^|]*|VALID|ULTIMATE|\).*$/\1/p' \
		| sort \
		| uniq \
		| wc -l \
	)
	status=$? ; [[ $status != 0 ]] && exit $status # TODO: remove after switching to -e
	[[ "$valid_count" -ge "$min_count" ]] || error "verify_failed" "$min_count"
}

cmd_init() {
	[ "$#" -eq 0 ] || usage init
	git config --add \
		remote.origin.fetch \
		"+refs/notes/signatures:refs/notes/signatures"
	git config --add \
		remote.origin.fetch \
		"+refs/tags/latest-signature:refs/tags/latest-signature"
	git config --add \
		remote.origin.push \
		"+refs/notes/signatures:refs/notes/signatures"
	git config --add \
		remote.origin.push \
		"+refs/tags/latest-signature:refs/tags/latest-signature"
}

cmd_import() {
	[ "$#" -eq 0 ] || usage import
	for server in $($SHUF -e ha.pool.sks-keyservers.net \
				hkp://p80.pool.sks-keyservers.net:80 \
				keyserver.ubuntu.com \
				hkp://keyserver.ubuntu.com:80 \
				pgp.mit.edu ) ;
	do
		# shellcheck disable=SC2046
		$GPG \
			--keyserver "$server" \
			--recv-keys $(xargs echo < .gitsigners) && { break || : ; }
	done
	sed 's/$/:6:/g' < .gitsigners | $GPG --import-ownertrust
}

cmd_pull() {
	[ "$#" -eq 0 ] || usage pull

	if git rev-parse refs/tags/latest-signature >/dev/null 2>&1; then
		git fetch origin refs/notes/signatures:refs/notes/origin/signatures +refs/tags/latest-signature:refs/tags/origin/latest-signature
	else
		git fetch origin refs/notes/signatures:refs/notes/origin/signatures
	fi
	git notes --ref signatures merge -s cat_sort_uniq origin/signatures
}

cmd_push() {
	[ "$#" -eq 0 ] || usage push

	if git rev-parse refs/tags/latest-signature >/dev/null 2>&1; then
		git push origin refs/notes/signatures +refs/tags/latest-signature
	else
		git push origin refs/notes/signatures
	fi
}

main "$@"
